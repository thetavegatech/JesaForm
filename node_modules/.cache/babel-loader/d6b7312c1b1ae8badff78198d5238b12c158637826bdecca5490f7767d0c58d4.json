{"ast":null,"code":"/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n/*namespace com.google.zxing.oned {*/\nimport BarcodeFormat from '../BarcodeFormat';\nimport DecodeHintType from '../DecodeHintType';\nimport FormatException from '../FormatException';\nimport NotFoundException from '../NotFoundException';\nimport Result from '../Result';\nimport ResultPoint from '../ResultPoint';\nimport StringBuilder from '../util/StringBuilder';\nimport System from '../util/System';\nimport OneDReader from './OneDReader';\n/**\n * <p>Decodes ITF barcodes.</p>\n *\n * @author Tjieco\n */\nvar ITFReader = /** @class */function (_super) {\n  __extends(ITFReader, _super);\n  function ITFReader() {\n    // private static W = 3; // Pixel width of a 3x wide line\n    // private static w = 2; // Pixel width of a 2x wide line\n    // private static N = 1; // Pixed width of a narrow line\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    // Stores the actual narrow line width of the image being decoded.\n    _this.narrowLineWidth = -1;\n    return _this;\n  }\n  // See ITFWriter.PATTERNS\n  /*\n     /!**\n   * Patterns of Wide / Narrow lines to indicate each digit\n   *!/\n  */\n  ITFReader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var e_1, _a;\n    // Find out where the Middle section (payload) starts & ends\n    var startRange = this.decodeStart(row);\n    var endRange = this.decodeEnd(row);\n    var result = new StringBuilder();\n    ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);\n    var resultString = result.toString();\n    var allowedLengths = null;\n    if (hints != null) {\n      allowedLengths = hints.get(DecodeHintType.ALLOWED_LENGTHS);\n    }\n    if (allowedLengths == null) {\n      allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;\n    }\n    // To avoid false positives with 2D barcodes (and other patterns), make\n    // an assumption that the decoded string must be a 'standard' length if it's short\n    var length = resultString.length;\n    var lengthOK = false;\n    var maxAllowedLength = 0;\n    try {\n      for (var allowedLengths_1 = __values(allowedLengths), allowedLengths_1_1 = allowedLengths_1.next(); !allowedLengths_1_1.done; allowedLengths_1_1 = allowedLengths_1.next()) {\n        var value = allowedLengths_1_1.value;\n        if (length === value) {\n          lengthOK = true;\n          break;\n        }\n        if (value > maxAllowedLength) {\n          maxAllowedLength = value;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (allowedLengths_1_1 && !allowedLengths_1_1.done && (_a = allowedLengths_1.return)) _a.call(allowedLengths_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    if (!lengthOK && length > maxAllowedLength) {\n      lengthOK = true;\n    }\n    if (!lengthOK) {\n      throw new FormatException();\n    }\n    var points = [new ResultPoint(startRange[1], rowNumber), new ResultPoint(endRange[0], rowNumber)];\n    var resultReturn = new Result(resultString, null,\n    // no natural byte representation for these barcodes\n    0, points, BarcodeFormat.ITF, new Date().getTime());\n    return resultReturn;\n  };\n  /*\n  /!**\n   * @param row          row of black/white values to search\n   * @param payloadStart offset of start pattern\n   * @param resultString {@link StringBuilder} to append decoded chars to\n   * @throws NotFoundException if decoding could not complete successfully\n   *!/*/\n  ITFReader.decodeMiddle = function (row, payloadStart, payloadEnd, resultString) {\n    // Digits are interleaved in pairs - 5 black lines for one digit, and the\n    // 5\n    // interleaved white lines for the second digit.\n    // Therefore, need to scan 10 lines and then\n    // split these into two arrays\n    var counterDigitPair = new Int32Array(10); // 10\n    var counterBlack = new Int32Array(5); // 5\n    var counterWhite = new Int32Array(5); // 5\n    counterDigitPair.fill(0);\n    counterBlack.fill(0);\n    counterWhite.fill(0);\n    while (payloadStart < payloadEnd) {\n      // Get 10 runs of black/white.\n      OneDReader.recordPattern(row, payloadStart, counterDigitPair);\n      // Split them into each array\n      for (var k = 0; k < 5; k++) {\n        var twoK = 2 * k;\n        counterBlack[k] = counterDigitPair[twoK];\n        counterWhite[k] = counterDigitPair[twoK + 1];\n      }\n      var bestMatch = ITFReader.decodeDigit(counterBlack);\n      resultString.append(bestMatch.toString());\n      bestMatch = this.decodeDigit(counterWhite);\n      resultString.append(bestMatch.toString());\n      counterDigitPair.forEach(function (counterDigit) {\n        payloadStart += counterDigit;\n      });\n    }\n  };\n  /*/!**\n   * Identify where the start of the middle / payload section starts.\n   *\n   * @param row row of black/white values to search\n   * @return Array, containing index of start of 'start block' and end of\n   *         'start block'\n   *!/*/\n  ITFReader.prototype.decodeStart = function (row) {\n    var endStart = ITFReader.skipWhiteSpace(row);\n    var startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);\n    // Determine the width of a narrow line in pixels. We can do this by\n    // getting the width of the start pattern and dividing by 4 because its\n    // made up of 4 narrow lines.\n    this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;\n    this.validateQuietZone(row, startPattern[0]);\n    return startPattern;\n  };\n  /*/!**\n   * The start & end patterns must be pre/post fixed by a quiet zone. This\n   * zone must be at least 10 times the width of a narrow line.  Scan back until\n   * we either get to the start of the barcode or match the necessary number of\n   * quiet zone pixels.\n   *\n   * Note: Its assumed the row is reversed when using this method to find\n   * quiet zone after the end pattern.\n   *\n   * ref: http://www.barcode-1.net/i25code.html\n   *\n   * @param row bit array representing the scanned barcode.\n   * @param startPattern index into row of the start or end pattern.\n   * @throws NotFoundException if the quiet zone cannot be found\n   *!/*/\n  ITFReader.prototype.validateQuietZone = function (row, startPattern) {\n    var quietCount = this.narrowLineWidth * 10; // expect to find this many pixels of quiet zone\n    // if there are not so many pixel at all let's try as many as possible\n    quietCount = quietCount < startPattern ? quietCount : startPattern;\n    for (var i = startPattern - 1; quietCount > 0 && i >= 0; i--) {\n      if (row.get(i)) {\n        break;\n      }\n      quietCount--;\n    }\n    if (quietCount !== 0) {\n      // Unable to find the necessary number of quiet zone pixels.\n      throw new NotFoundException();\n    }\n  };\n  /*\n  /!**\n   * Skip all whitespace until we get to the first black line.\n   *\n   * @param row row of black/white values to search\n   * @return index of the first black line.\n   * @throws NotFoundException Throws exception if no black lines are found in the row\n   *!/*/\n  ITFReader.skipWhiteSpace = function (row) {\n    var width = row.getSize();\n    var endStart = row.getNextSet(0);\n    if (endStart === width) {\n      throw new NotFoundException();\n    }\n    return endStart;\n  };\n  /*/!**\n   * Identify where the end of the middle / payload section ends.\n   *\n   * @param row row of black/white values to search\n   * @return Array, containing index of start of 'end block' and end of 'end\n   *         block'\n   *!/*/\n  ITFReader.prototype.decodeEnd = function (row) {\n    // For convenience, reverse the row and then\n    // search from 'the start' for the end block\n    row.reverse();\n    try {\n      var endStart = ITFReader.skipWhiteSpace(row);\n      var endPattern = void 0;\n      try {\n        endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);\n      } catch (error) {\n        if (error instanceof NotFoundException) {\n          endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);\n        }\n      }\n      // The start & end patterns must be pre/post fixed by a quiet zone. This\n      // zone must be at least 10 times the width of a narrow line.\n      // ref: http://www.barcode-1.net/i25code.html\n      this.validateQuietZone(row, endPattern[0]);\n      // Now recalculate the indices of where the 'endblock' starts & stops to\n      // accommodate\n      // the reversed nature of the search\n      var temp = endPattern[0];\n      endPattern[0] = row.getSize() - endPattern[1];\n      endPattern[1] = row.getSize() - temp;\n      return endPattern;\n    } finally {\n      // Put the row back the right way.\n      row.reverse();\n    }\n  };\n  /*\n  /!**\n   * @param row       row of black/white values to search\n   * @param rowOffset position to start search\n   * @param pattern   pattern of counts of number of black and white pixels that are\n   *                  being searched for as a pattern\n   * @return start/end horizontal offset of guard pattern, as an array of two\n   *         ints\n   * @throws NotFoundException if pattern is not found\n   *!/*/\n  ITFReader.findGuardPattern = function (row, rowOffset, pattern) {\n    var patternLength = pattern.length;\n    var counters = new Int32Array(patternLength);\n    var width = row.getSize();\n    var isWhite = false;\n    var counterPosition = 0;\n    var patternStart = rowOffset;\n    counters.fill(0);\n    for (var x = rowOffset; x < width; x++) {\n      if (row.get(x) !== isWhite) {\n        counters[counterPosition]++;\n      } else {\n        if (counterPosition === patternLength - 1) {\n          if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {\n            return [patternStart, x];\n          }\n          patternStart += counters[0] + counters[1];\n          System.arraycopy(counters, 2, counters, 0, counterPosition - 1);\n          counters[counterPosition - 1] = 0;\n          counters[counterPosition] = 0;\n          counterPosition--;\n        } else {\n          counterPosition++;\n        }\n        counters[counterPosition] = 1;\n        isWhite = !isWhite;\n      }\n    }\n    throw new NotFoundException();\n  };\n  /*/!**\n   * Attempts to decode a sequence of ITF black/white lines into single\n   * digit.\n   *\n   * @param counters the counts of runs of observed black/white/black/... values\n   * @return The decoded digit\n   * @throws NotFoundException if digit cannot be decoded\n   *!/*/\n  ITFReader.decodeDigit = function (counters) {\n    var bestVariance = ITFReader.MAX_AVG_VARIANCE; // worst variance we'll accept\n    var bestMatch = -1;\n    var max = ITFReader.PATTERNS.length;\n    for (var i = 0; i < max; i++) {\n      var pattern = ITFReader.PATTERNS[i];\n      var variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);\n      if (variance < bestVariance) {\n        bestVariance = variance;\n        bestMatch = i;\n      } else if (variance === bestVariance) {\n        // if we find a second 'best match' with the same variance, we can not reliably report to have a suitable match\n        bestMatch = -1;\n      }\n    }\n    if (bestMatch >= 0) {\n      return bestMatch % 10;\n    } else {\n      throw new NotFoundException();\n    }\n  };\n  ITFReader.PATTERNS = [Int32Array.from([1, 1, 2, 2, 1]), Int32Array.from([2, 1, 1, 1, 2]), Int32Array.from([1, 2, 1, 1, 2]), Int32Array.from([2, 2, 1, 1, 1]), Int32Array.from([1, 1, 2, 1, 2]), Int32Array.from([2, 1, 2, 1, 1]), Int32Array.from([1, 2, 2, 1, 1]), Int32Array.from([1, 1, 1, 2, 2]), Int32Array.from([2, 1, 1, 2, 1]), Int32Array.from([1, 2, 1, 2, 1]), Int32Array.from([1, 1, 3, 3, 1]), Int32Array.from([3, 1, 1, 1, 3]), Int32Array.from([1, 3, 1, 1, 3]), Int32Array.from([3, 3, 1, 1, 1]), Int32Array.from([1, 1, 3, 1, 3]), Int32Array.from([3, 1, 3, 1, 1]), Int32Array.from([1, 3, 3, 1, 1]), Int32Array.from([1, 1, 1, 3, 3]), Int32Array.from([3, 1, 1, 3, 1]), Int32Array.from([1, 3, 1, 3, 1]) // 9\n  ];\n  ITFReader.MAX_AVG_VARIANCE = 0.38;\n  ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;\n  /* /!** Valid ITF lengths. Anything longer than the largest value is also allowed. *!/*/\n  ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];\n  /*/!**\n   * Start/end guard pattern.\n   *\n   * Note: The end pattern is reversed because the row is reversed before\n   * searching for the END_PATTERN\n   *!/*/\n  ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);\n  ITFReader.END_PATTERN_REVERSED = [Int32Array.from([1, 1, 2]), Int32Array.from([1, 1, 3]) // 3x\n  ];\n  return ITFReader;\n}(OneDReader);\nexport default ITFReader;","map":{"version":3,"names":["BarcodeFormat","DecodeHintType","FormatException","NotFoundException","Result","ResultPoint","StringBuilder","System","OneDReader","ITFReader","_super","__extends","_this","apply","arguments","narrowLineWidth","prototype","decodeRow","rowNumber","row","hints","startRange","decodeStart","endRange","decodeEnd","result","decodeMiddle","resultString","toString","allowedLengths","get","ALLOWED_LENGTHS","DEFAULT_ALLOWED_LENGTHS","length","lengthOK","maxAllowedLength","allowedLengths_1","__values","allowedLengths_1_1","next","done","value","points","resultReturn","ITF","Date","getTime","payloadStart","payloadEnd","counterDigitPair","Int32Array","counterBlack","counterWhite","fill","recordPattern","k","twoK","bestMatch","decodeDigit","append","forEach","counterDigit","endStart","skipWhiteSpace","startPattern","findGuardPattern","START_PATTERN","validateQuietZone","quietCount","i","width","getSize","getNextSet","reverse","endPattern","END_PATTERN_REVERSED","error","temp","rowOffset","pattern","patternLength","counters","isWhite","counterPosition","patternStart","x","patternMatchVariance","MAX_INDIVIDUAL_VARIANCE","MAX_AVG_VARIANCE","arraycopy","bestVariance","max","PATTERNS","variance","from"],"sources":["../../../../src/core/oned/ITFReader.ts"],"sourcesContent":[null],"mappings":"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,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAChC5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAE;EAAA,CACrC;EAEYrF,SAAA,CAAA+E,gBAAgB,GAAG,IAAI;EACvB/E,SAAA,CAAA8E,uBAAuB,GAAG,GAAG;EAI5C;EACe9E,SAAA,CAAAuB,uBAAuB,GAAa,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC;EAKnE;;;;;;EAMevB,SAAA,CAAAyD,aAAa,GAAGhB,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;EAC7CrF,SAAA,CAAAkE,oBAAoB,GAAiB,CAChDzB,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAC1B5C,UAAU,CAAC4C,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,CAAE;EAAA,CAC/B;EAgUL,OAAArF,SAAC;CAAA,CAlXsCD,UAAU;eAA5BC,SAAS","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}