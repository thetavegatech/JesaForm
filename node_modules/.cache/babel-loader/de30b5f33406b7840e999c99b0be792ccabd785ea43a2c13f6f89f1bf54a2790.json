{"ast":null,"code":"/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport AlignmentPattern from './AlignmentPattern';\nimport NotFoundException from '../../NotFoundException';\n/*import java.util.ArrayList;*/\n/*import java.util.List;*/\n/**\n * <p>This class attempts to find alignment patterns in a QR Code. Alignment patterns look like finder\n * patterns but are smaller and appear at regular intervals throughout the image.</p>\n *\n * <p>At the moment this only looks for the bottom-right alignment pattern.</p>\n *\n * <p>This is mostly a simplified copy of {@link FinderPatternFinder}. It is copied,\n * pasted and stripped down here for maximum performance but does unfortunately duplicate\n * some code.</p>\n *\n * <p>This class is thread-safe but not reentrant. Each thread must allocate its own object.</p>\n *\n * @author Sean Owen\n */\nvar AlignmentPatternFinder = /** @class */function () {\n  /**\n   * <p>Creates a finder that will look in a portion of the whole image.</p>\n   *\n   * @param image image to search\n   * @param startX left column from which to start searching\n   * @param startY top row from which to start searching\n   * @param width width of region to search\n   * @param height height of region to search\n   * @param moduleSize estimated module size so far\n   */\n  function AlignmentPatternFinder(image, startX /*int*/, startY /*int*/, width /*int*/, height /*int*/, moduleSize /*float*/, resultPointCallback) {\n    this.image = image;\n    this.startX = startX;\n    this.startY = startY;\n    this.width = width;\n    this.height = height;\n    this.moduleSize = moduleSize;\n    this.resultPointCallback = resultPointCallback;\n    this.possibleCenters = []; // new Array<any>(5))\n    // TYPESCRIPTPORT: array initialization without size as the length is checked below\n    this.crossCheckStateCount = new Int32Array(3);\n  }\n  /**\n   * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since\n   * it's pretty performance-critical and so is written to be fast foremost.</p>\n   *\n   * @return {@link AlignmentPattern} if found\n   * @throws NotFoundException if not found\n   */\n  AlignmentPatternFinder.prototype.find = function () {\n    var startX = this.startX;\n    var height = this.height;\n    var width = this.width;\n    var maxJ = startX + width;\n    var middleI = this.startY + height / 2;\n    // We are looking for black/white/black modules in 1:1:1 ratio\n    // this tracks the number of black/white/black modules seen so far\n    var stateCount = new Int32Array(3);\n    var image = this.image;\n    for (var iGen = 0; iGen < height; iGen++) {\n      // Search from middle outwards\n      var i = middleI + ((iGen & 0x01) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));\n      stateCount[0] = 0;\n      stateCount[1] = 0;\n      stateCount[2] = 0;\n      var j = startX;\n      // Burn off leading white pixels before anything else; if we start in the middle of\n      // a white run, it doesn't make sense to count its length, since we don't know if the\n      // white run continued to the left of the start point\n      while (j < maxJ && !image.get(j, i)) {\n        j++;\n      }\n      var currentState = 0;\n      while (j < maxJ) {\n        if (image.get(j, i)) {\n          // Black pixel\n          if (currentState === 1) {\n            // Counting black pixels\n            stateCount[1]++;\n          } else {\n            // Counting white pixels\n            if (currentState === 2) {\n              // A winner?\n              if (this.foundPatternCross(stateCount)) {\n                // Yes\n                var confirmed = this.handlePossibleCenter(stateCount, i, j);\n                if (confirmed !== null) {\n                  return confirmed;\n                }\n              }\n              stateCount[0] = stateCount[2];\n              stateCount[1] = 1;\n              stateCount[2] = 0;\n              currentState = 1;\n            } else {\n              stateCount[++currentState]++;\n            }\n          }\n        } else {\n          // White pixel\n          if (currentState === 1) {\n            // Counting black pixels\n            currentState++;\n          }\n          stateCount[currentState]++;\n        }\n        j++;\n      }\n      if (this.foundPatternCross(stateCount)) {\n        var confirmed = this.handlePossibleCenter(stateCount, i, maxJ);\n        if (confirmed !== null) {\n          return confirmed;\n        }\n      }\n    }\n    // Hmm, nothing we saw was observed and confirmed twice. If we had\n    // any guess at all, return it.\n    if (this.possibleCenters.length !== 0) {\n      return this.possibleCenters[0];\n    }\n    throw new NotFoundException();\n  };\n  /**\n   * Given a count of black/white/black pixels just seen and an end position,\n   * figures the location of the center of this black/white/black run.\n   */\n  AlignmentPatternFinder.centerFromEnd = function (stateCount, end /*int*/) {\n    return end - stateCount[2] - stateCount[1] / 2.0;\n  };\n  /**\n   * @param stateCount count of black/white/black pixels just read\n   * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios\n   *         used by alignment patterns to be considered a match\n   */\n  AlignmentPatternFinder.prototype.foundPatternCross = function (stateCount) {\n    var moduleSize = this.moduleSize;\n    var maxVariance = moduleSize / 2.0;\n    for (var i = 0; i < 3; i++) {\n      if (Math.abs(moduleSize - stateCount[i]) >= maxVariance) {\n        return false;\n      }\n    }\n    return true;\n  };\n  /**\n   * <p>After a horizontal scan finds a potential alignment pattern, this method\n   * \"cross-checks\" by scanning down vertically through the center of the possible\n   * alignment pattern to see if the same proportion is detected.</p>\n   *\n   * @param startI row where an alignment pattern was detected\n   * @param centerJ center of the section that appears to cross an alignment pattern\n   * @param maxCount maximum reasonable number of modules that should be\n   * observed in any reading state, based on the results of the horizontal scan\n   * @return vertical center of alignment pattern, or {@link Float#NaN} if not found\n   */\n  AlignmentPatternFinder.prototype.crossCheckVertical = function (startI /*int*/, centerJ /*int*/, maxCount /*int*/, originalStateCountTotal /*int*/) {\n    var image = this.image;\n    var maxI = image.getHeight();\n    var stateCount = this.crossCheckStateCount;\n    stateCount[0] = 0;\n    stateCount[1] = 0;\n    stateCount[2] = 0;\n    // Start counting up from center\n    var i = startI;\n    while (i >= 0 && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i--;\n    }\n    // If already too many modules in this state or ran off the edge:\n    if (i < 0 || stateCount[1] > maxCount) {\n      return NaN;\n    }\n    while (i >= 0 && !image.get(centerJ, i) && stateCount[0] <= maxCount) {\n      stateCount[0]++;\n      i--;\n    }\n    if (stateCount[0] > maxCount) {\n      return NaN;\n    }\n    // Now also count down from center\n    i = startI + 1;\n    while (i < maxI && image.get(centerJ, i) && stateCount[1] <= maxCount) {\n      stateCount[1]++;\n      i++;\n    }\n    if (i === maxI || stateCount[1] > maxCount) {\n      return NaN;\n    }\n    while (i < maxI && !image.get(centerJ, i) && stateCount[2] <= maxCount) {\n      stateCount[2]++;\n      i++;\n    }\n    if (stateCount[2] > maxCount) {\n      return NaN;\n    }\n    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n    if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {\n      return NaN;\n    }\n    return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i) : NaN;\n  };\n  /**\n   * <p>This is called when a horizontal scan finds a possible alignment pattern. It will\n   * cross check with a vertical scan, and if successful, will see if this pattern had been\n   * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have\n   * found the alignment pattern.</p>\n   *\n   * @param stateCount reading state module counts from horizontal scan\n   * @param i row where alignment pattern may be found\n   * @param j end of possible alignment pattern in row\n   * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not\n   */\n  AlignmentPatternFinder.prototype.handlePossibleCenter = function (stateCount, i /*int*/, j /*int*/) {\n    var e_1, _a;\n    var stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];\n    var centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j);\n    var centerI = this.crossCheckVertical(i, /*(int) */centerJ, 2 * stateCount[1], stateCountTotal);\n    if (!isNaN(centerI)) {\n      var estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3.0;\n      try {\n        for (var _b = __values(this.possibleCenters), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var center = _c.value;\n          // Look for about the same center and module size:\n          if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {\n            return center.combineEstimate(centerI, centerJ, estimatedModuleSize);\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      // Hadn't found this before; save it\n      var point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);\n      this.possibleCenters.push(point);\n      if (this.resultPointCallback !== null && this.resultPointCallback !== undefined) {\n        this.resultPointCallback.foundPossibleResultPoint(point);\n      }\n    }\n    return null;\n  };\n  return AlignmentPatternFinder;\n}();\nexport default AlignmentPatternFinder;","map":{"version":3,"names":["AlignmentPattern","NotFoundException","AlignmentPatternFinder","image","startX","startY","width","height","moduleSize","resultPointCallback","possibleCenters","crossCheckStateCount","Int32Array","prototype","find","maxJ","middleI","stateCount","iGen","i","Math","floor","j","get","currentState","foundPatternCross","confirmed","handlePossibleCenter","length","centerFromEnd","end","maxVariance","abs","crossCheckVertical","startI","centerJ","maxCount","originalStateCountTotal","maxI","getHeight","NaN","stateCountTotal","centerI","isNaN","estimatedModuleSize","_b","__values","_c","next","done","center","value","aboutEquals","combineEstimate","point","push","undefined","foundPossibleResultPoint"],"sources":["../../../../../src/core/qrcode/detector/AlignmentPatternFinder.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}