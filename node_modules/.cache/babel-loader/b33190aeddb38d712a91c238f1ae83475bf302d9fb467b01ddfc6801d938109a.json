{"ast":null,"code":"/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*namespace com.google.zxing.qrcode {*/\nimport BarcodeFormat from '../BarcodeFormat';\nimport BitMatrix from '../common/BitMatrix';\nimport DecodeHintType from '../DecodeHintType';\nimport NotFoundException from '../NotFoundException';\nimport Result from '../Result';\nimport ResultMetadataType from '../ResultMetadataType';\n// import DetectorResult from '../common/DetectorResult';\nimport Decoder from './decoder/Decoder';\nimport QRCodeDecoderMetaData from './decoder/QRCodeDecoderMetaData';\nimport Detector from './detector/Detector';\n/*import java.util.List;*/\n/*import java.util.Map;*/\n/**\n * This implementation can detect and decode QR Codes in an image.\n *\n * @author Sean Owen\n */\nvar QRCodeReader = /** @class */function () {\n  function QRCodeReader() {\n    this.decoder = new Decoder();\n  }\n  QRCodeReader.prototype.getDecoder = function () {\n    return this.decoder;\n  };\n  /**\n   * Locates and decodes a QR code in an image.\n   *\n   * @return a representing: string the content encoded by the QR code\n   * @throws NotFoundException if a QR code cannot be found\n   * @throws FormatException if a QR code cannot be decoded\n   * @throws ChecksumException if error correction fails\n   */\n  /*@Override*/\n  // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {\n  //   return this.decode(image, null)\n  // }\n  /*@Override*/\n  QRCodeReader.prototype.decode = function (image, hints) {\n    var decoderResult;\n    var points;\n    if (hints !== undefined && hints !== null && undefined !== hints.get(DecodeHintType.PURE_BARCODE)) {\n      var bits = QRCodeReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decodeBitMatrix(bits, hints);\n      points = QRCodeReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector(image.getBlackMatrix()).detect(hints);\n      decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);\n      points = detectorResult.getPoints();\n    }\n    // If the code was mirrored: swap the bottom-left and the top-right points.\n    if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {\n      decoderResult.getOther().applyMirroredCorrection(points);\n    }\n    var result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), undefined, points, BarcodeFormat.QR_CODE, undefined);\n    var byteSegments = decoderResult.getByteSegments();\n    if (byteSegments !== null) {\n      result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);\n    }\n    var ecLevel = decoderResult.getECLevel();\n    if (ecLevel !== null) {\n      result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n    if (decoderResult.hasStructuredAppend()) {\n      result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());\n      result.putMetadata(ResultMetadataType.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());\n    }\n    return result;\n  };\n  /*@Override*/\n  QRCodeReader.prototype.reset = function () {\n    // do nothing\n  };\n  /**\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n   * which contains only an unrotated, unskewed, image of a code, with some white border\n   * around it. This is a specialized method that works exceptionally fast in this special\n   * case.\n   *\n   * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)\n   */\n  QRCodeReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n    if (leftTopBlack === null || rightBottomBlack === null) {\n      throw new NotFoundException();\n    }\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0];\n    // Sanity check!\n    if (left >= right || top >= bottom) {\n      throw new NotFoundException();\n    }\n    if (bottom - top !== right - left) {\n      // Special case, where bottom-right module wasn't black so we found something else in the last row\n      // Assume it's a square, so use height as the width\n      right = left + (bottom - top);\n      if (right >= image.getWidth()) {\n        // Abort if that would not make sense -- off image\n        throw new NotFoundException();\n      }\n    }\n    var matrixWidth = Math.round((right - left + 1) / moduleSize);\n    var matrixHeight = Math.round((bottom - top + 1) / moduleSize);\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException();\n    }\n    if (matrixHeight !== matrixWidth) {\n      // Only possibly decode square regions\n      throw new NotFoundException();\n    }\n    // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n    var nudge = /*(int) */Math.floor(moduleSize / 2.0);\n    top += nudge;\n    left += nudge;\n    // But careful that this does not sample off the edge\n    // \"right\" is the farthest-right valid pixel location -- right+1 is not necessarily\n    // This is positive by how much the inner x loop below would be too large\n    var nudgedTooFarRight = left + /*(int) */Math.floor((matrixWidth - 1) * moduleSize) - right;\n    if (nudgedTooFarRight > 0) {\n      if (nudgedTooFarRight > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException();\n      }\n      left -= nudgedTooFarRight;\n    }\n    // See logic above\n    var nudgedTooFarDown = top + /*(int) */Math.floor((matrixHeight - 1) * moduleSize) - bottom;\n    if (nudgedTooFarDown > 0) {\n      if (nudgedTooFarDown > nudge) {\n        // Neither way fits; abort\n        throw new NotFoundException();\n      }\n      top -= nudgedTooFarDown;\n    }\n    // Now just read off the bits\n    var bits = new BitMatrix(matrixWidth, matrixHeight);\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top + /*(int) */Math.floor(y * moduleSize);\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left + /*(int) */Math.floor(x * moduleSize), iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n    return bits;\n  };\n  QRCodeReader.moduleSize = function (leftTopBlack, image) {\n    var height = image.getHeight();\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n    var inBlack = true;\n    var transitions = 0;\n    while (x < width && y < height) {\n      if (inBlack !== image.get(x, y)) {\n        if (++transitions === 5) {\n          break;\n        }\n        inBlack = !inBlack;\n      }\n      x++;\n      y++;\n    }\n    if (x === width || y === height) {\n      throw new NotFoundException();\n    }\n    return (x - leftTopBlack[0]) / 7.0;\n  };\n  QRCodeReader.NO_POINTS = new Array();\n  return QRCodeReader;\n}();\nexport default QRCodeReader;","map":{"version":3,"names":["BarcodeFormat","BitMatrix","DecodeHintType","NotFoundException","Result","ResultMetadataType","Decoder","QRCodeDecoderMetaData","Detector","QRCodeReader","decoder","prototype","getDecoder","decode","image","hints","decoderResult","points","undefined","get","PURE_BARCODE","bits","extractPureBits","getBlackMatrix","decodeBitMatrix","NO_POINTS","detectorResult","detect","getBits","getPoints","getOther","applyMirroredCorrection","result","getText","getRawBytes","QR_CODE","byteSegments","getByteSegments","putMetadata","BYTE_SEGMENTS","ecLevel","getECLevel","ERROR_CORRECTION_LEVEL","hasStructuredAppend","STRUCTURED_APPEND_SEQUENCE","getStructuredAppendSequenceNumber","STRUCTURED_APPEND_PARITY","getStructuredAppendParity","reset","leftTopBlack","getTopLeftOnBit","rightBottomBlack","getBottomRightOnBit","moduleSize","top","bottom","left","right","getWidth","matrixWidth","Math","round","matrixHeight","nudge","floor","nudgedTooFarRight","nudgedTooFarDown","y","iOffset","x","set","height","getHeight","width","inBlack","transitions","Array"],"sources":["../../../../src/core/qrcode/QRCodeReader.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}