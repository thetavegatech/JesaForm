{"ast":null,"code":"import BarcodeFormat from '../BarcodeFormat';\nimport BitMatrix from '../common/BitMatrix';\nimport DecodeHintType from '../DecodeHintType';\nimport NotFoundException from '../NotFoundException';\nimport Result from '../Result';\nimport ResultMetadataType from '../ResultMetadataType';\nimport System from '../util/System';\nimport Decoder from './decoder/Decoder';\nimport Detector from './detector/Detector';\n/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * This implementation can detect and decode Data Matrix codes in an image.\n *\n * @author bbrown@google.com (Brian Brown)\n */\nvar DataMatrixReader = /** @class */function () {\n  function DataMatrixReader() {\n    this.decoder = new Decoder();\n  }\n  /**\n   * Locates and decodes a Data Matrix code in an image.\n   *\n   * @return a String representing the content encoded by the Data Matrix code\n   * @throws NotFoundException if a Data Matrix code cannot be found\n   * @throws FormatException if a Data Matrix code cannot be decoded\n   * @throws ChecksumException if error correction fails\n   */\n  // @Override\n  // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {\n  //   return decode(image, null);\n  // }\n  // @Override\n  DataMatrixReader.prototype.decode = function (image, hints) {\n    if (hints === void 0) {\n      hints = null;\n    }\n    var decoderResult;\n    var points;\n    if (hints != null && hints.has(DecodeHintType.PURE_BARCODE)) {\n      var bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());\n      decoderResult = this.decoder.decode(bits);\n      points = DataMatrixReader.NO_POINTS;\n    } else {\n      var detectorResult = new Detector(image.getBlackMatrix()).detect();\n      decoderResult = this.decoder.decode(detectorResult.getBits());\n      points = detectorResult.getPoints();\n    }\n    var rawBytes = decoderResult.getRawBytes();\n    var result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat.DATA_MATRIX, System.currentTimeMillis());\n    var byteSegments = decoderResult.getByteSegments();\n    if (byteSegments != null) {\n      result.putMetadata(ResultMetadataType.BYTE_SEGMENTS, byteSegments);\n    }\n    var ecLevel = decoderResult.getECLevel();\n    if (ecLevel != null) {\n      result.putMetadata(ResultMetadataType.ERROR_CORRECTION_LEVEL, ecLevel);\n    }\n    return result;\n  };\n  // @Override\n  DataMatrixReader.prototype.reset = function () {\n    // do nothing\n  };\n  /**\n   * This method detects a code in a \"pure\" image -- that is, pure monochrome image\n   * which contains only an unrotated, unskewed, image of a code, with some white border\n   * around it. This is a specialized method that works exceptionally fast in this special\n   * case.\n   *\n   * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)\n   */\n  DataMatrixReader.extractPureBits = function (image) {\n    var leftTopBlack = image.getTopLeftOnBit();\n    var rightBottomBlack = image.getBottomRightOnBit();\n    if (leftTopBlack == null || rightBottomBlack == null) {\n      throw new NotFoundException();\n    }\n    var moduleSize = this.moduleSize(leftTopBlack, image);\n    var top = leftTopBlack[1];\n    var bottom = rightBottomBlack[1];\n    var left = leftTopBlack[0];\n    var right = rightBottomBlack[0];\n    var matrixWidth = (right - left + 1) / moduleSize;\n    var matrixHeight = (bottom - top + 1) / moduleSize;\n    if (matrixWidth <= 0 || matrixHeight <= 0) {\n      throw new NotFoundException();\n    }\n    // Push in the \"border\" by half the module width so that we start\n    // sampling in the middle of the module. Just in case the image is a\n    // little off, this will help recover.\n    var nudge = moduleSize / 2;\n    top += nudge;\n    left += nudge;\n    // Now just read off the bits\n    var bits = new BitMatrix(matrixWidth, matrixHeight);\n    for (var y = 0; y < matrixHeight; y++) {\n      var iOffset = top + y * moduleSize;\n      for (var x = 0; x < matrixWidth; x++) {\n        if (image.get(left + x * moduleSize, iOffset)) {\n          bits.set(x, y);\n        }\n      }\n    }\n    return bits;\n  };\n  DataMatrixReader.moduleSize = function (leftTopBlack, image) {\n    var width = image.getWidth();\n    var x = leftTopBlack[0];\n    var y = leftTopBlack[1];\n    while (x < width && image.get(x, y)) {\n      x++;\n    }\n    if (x === width) {\n      throw new NotFoundException();\n    }\n    var moduleSize = x - leftTopBlack[0];\n    if (moduleSize === 0) {\n      throw new NotFoundException();\n    }\n    return moduleSize;\n  };\n  DataMatrixReader.NO_POINTS = [];\n  return DataMatrixReader;\n}();\nexport default DataMatrixReader;","map":{"version":3,"names":["BarcodeFormat","BitMatrix","DecodeHintType","NotFoundException","Result","ResultMetadataType","System","Decoder","Detector","DataMatrixReader","decoder","prototype","decode","image","hints","decoderResult","points","has","PURE_BARCODE","bits","extractPureBits","getBlackMatrix","NO_POINTS","detectorResult","detect","getBits","getPoints","rawBytes","getRawBytes","result","getText","length","DATA_MATRIX","currentTimeMillis","byteSegments","getByteSegments","putMetadata","BYTE_SEGMENTS","ecLevel","getECLevel","ERROR_CORRECTION_LEVEL","reset","leftTopBlack","getTopLeftOnBit","rightBottomBlack","getBottomRightOnBit","moduleSize","top","bottom","left","right","matrixWidth","matrixHeight","nudge","y","iOffset","x","get","set","width","getWidth"],"sources":["../../../../src/core/datamatrix/DataMatrixReader.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}