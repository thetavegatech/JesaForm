{"ast":null,"code":"/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n// import java.util.Collection;\n// import java.util.Collections;\nimport Collections from '../../util/Collections';\n// import java.util.Comparator;\n// import java.util.Iterator;\n// import java.util.LinkedList;\nimport State from './State';\nimport * as C from './EncoderConstants';\nimport * as CharMap from './CharMap';\nimport * as ShiftTable from './ShiftTable';\nimport StringUtils from '../../common/StringUtils';\n/**\n * This produces nearly optimal encodings of text into the first-level of\n * encoding used by Aztec code.\n *\n * It uses a dynamic algorithm.  For each prefix of the string, it determines\n * a set of encodings that could lead to this prefix.  We repeatedly add a\n * character and generate a new set of optimal encodings until we have read\n * through the entire input.\n *\n * @author Frank Yellin\n * @author Rustam Abdullaev\n */\nvar HighLevelEncoder = /** @class */function () {\n  function HighLevelEncoder(text) {\n    this.text = text;\n  }\n  /**\n   * @return text represented by this encoder encoded as a {@link BitArray}\n   */\n  HighLevelEncoder.prototype.encode = function () {\n    var spaceCharCode = StringUtils.getCharCode(' ');\n    var lineBreakCharCode = StringUtils.getCharCode('\\n');\n    var states = Collections.singletonList(State.INITIAL_STATE);\n    for (var index = 0; index < this.text.length; index++) {\n      var pairCode = void 0;\n      var nextChar = index + 1 < this.text.length ? this.text[index + 1] : 0;\n      switch (this.text[index]) {\n        case StringUtils.getCharCode('\\r'):\n          pairCode = nextChar === lineBreakCharCode ? 2 : 0;\n          break;\n        case StringUtils.getCharCode('.'):\n          pairCode = nextChar === spaceCharCode ? 3 : 0;\n          break;\n        case StringUtils.getCharCode(','):\n          pairCode = nextChar === spaceCharCode ? 4 : 0;\n          break;\n        case StringUtils.getCharCode(':'):\n          pairCode = nextChar === spaceCharCode ? 5 : 0;\n          break;\n        default:\n          pairCode = 0;\n      }\n      if (pairCode > 0) {\n        // We have one of the four special PUNCT pairs.  Treat them specially.\n        // Get a new set of states for the two new characters.\n        states = HighLevelEncoder.updateStateListForPair(states, index, pairCode);\n        index++;\n      } else {\n        // Get a new set of states for the new character.\n        states = this.updateStateListForChar(states, index);\n      }\n    }\n    // We are left with a set of states.  Find the shortest one.\n    var minState = Collections.min(states, function (a, b) {\n      return a.getBitCount() - b.getBitCount();\n    });\n    // Convert it to a bit array, and return.\n    return minState.toBitArray(this.text);\n  };\n  // We update a set of states for a new character by updating each state\n  // for the new character, merging the results, and then removing the\n  // non-optimal states.\n  HighLevelEncoder.prototype.updateStateListForChar = function (states, index) {\n    var e_1, _a;\n    var result = [];\n    try {\n      for (var states_1 = __values(states), states_1_1 = states_1.next(); !states_1_1.done; states_1_1 = states_1.next()) {\n        var state = states_1_1.value /*State*/;\n        this.updateStateForChar(state, index, result);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (states_1_1 && !states_1_1.done && (_a = states_1.return)) _a.call(states_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return HighLevelEncoder.simplifyStates(result);\n  };\n  // Return a set of states that represent the possible ways of updating this\n  // state for the next character.  The resulting set of states are added to\n  // the \"result\" list.\n  HighLevelEncoder.prototype.updateStateForChar = function (state, index, result) {\n    var ch = this.text[index] & 0xff;\n    var charInCurrentTable = CharMap.CHAR_MAP[state.getMode()][ch] > 0;\n    var stateNoBinary = null;\n    for (var mode /*int*/ = 0; mode <= C.MODE_PUNCT; mode++) {\n      var charInMode = CharMap.CHAR_MAP[mode][ch];\n      if (charInMode > 0) {\n        if (stateNoBinary == null) {\n          // Only create stateNoBinary the first time it's required.\n          stateNoBinary = state.endBinaryShift(index);\n        }\n        // Try generating the character by latching to its mode\n        if (!charInCurrentTable || mode === state.getMode() || mode === C.MODE_DIGIT) {\n          // If the character is in the current table, we don't want to latch to\n          // any other mode except possibly digit (which uses only 4 bits).  Any\n          // other latch would be equally successful *after* this character, and\n          // so wouldn't save any bits.\n          var latchState = stateNoBinary.latchAndAppend(mode, charInMode);\n          result.push(latchState);\n        }\n        // Try generating the character by switching to its mode.\n        if (!charInCurrentTable && ShiftTable.SHIFT_TABLE[state.getMode()][mode] >= 0) {\n          // It never makes sense to temporarily shift to another mode if the\n          // character exists in the current mode.  That can never save bits.\n          var shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);\n          result.push(shiftState);\n        }\n      }\n    }\n    if (state.getBinaryShiftByteCount() > 0 || CharMap.CHAR_MAP[state.getMode()][ch] === 0) {\n      // It's never worthwhile to go into binary shift mode if you're not already\n      // in binary shift mode, and the character exists in your current mode.\n      // That can never save bits over just outputting the char in the current mode.\n      var binaryState = state.addBinaryShiftChar(index);\n      result.push(binaryState);\n    }\n  };\n  HighLevelEncoder.updateStateListForPair = function (states, index, pairCode) {\n    var e_2, _a;\n    var result = [];\n    try {\n      for (var states_2 = __values(states), states_2_1 = states_2.next(); !states_2_1.done; states_2_1 = states_2.next()) {\n        var state = states_2_1.value /*State*/;\n        this.updateStateForPair(state, index, pairCode, result);\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (states_2_1 && !states_2_1.done && (_a = states_2.return)) _a.call(states_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    return this.simplifyStates(result);\n  };\n  HighLevelEncoder.updateStateForPair = function (state, index, pairCode, result) {\n    var stateNoBinary = state.endBinaryShift(index);\n    // Possibility 1.  Latch to C.MODE_PUNCT, and then append this code\n    result.push(stateNoBinary.latchAndAppend(C.MODE_PUNCT, pairCode));\n    if (state.getMode() !== C.MODE_PUNCT) {\n      // Possibility 2.  Shift to C.MODE_PUNCT, and then append this code.\n      // Every state except C.MODE_PUNCT (handled above) can shift\n      result.push(stateNoBinary.shiftAndAppend(C.MODE_PUNCT, pairCode));\n    }\n    if (pairCode === 3 || pairCode === 4) {\n      // both characters are in DIGITS.  Sometimes better to just add two digits\n      var digitState = stateNoBinary.latchAndAppend(C.MODE_DIGIT, 16 - pairCode) // period or comma in DIGIT\n      .latchAndAppend(C.MODE_DIGIT, 1); // space in DIGIT\n      result.push(digitState);\n    }\n    if (state.getBinaryShiftByteCount() > 0) {\n      // It only makes sense to do the characters as binary if we're already\n      // in binary mode.\n      var binaryState = state.addBinaryShiftChar(index).addBinaryShiftChar(index + 1);\n      result.push(binaryState);\n    }\n  };\n  HighLevelEncoder.simplifyStates = function (states) {\n    var e_3, _a, e_4, _b;\n    var result = [];\n    try {\n      for (var states_3 = __values(states), states_3_1 = states_3.next(); !states_3_1.done; states_3_1 = states_3.next()) {\n        var newState = states_3_1.value;\n        var add = true;\n        var _loop_1 = function (oldState) {\n          if (oldState.isBetterThanOrEqualTo(newState)) {\n            add = false;\n            return \"break\";\n          }\n          if (newState.isBetterThanOrEqualTo(oldState)) {\n            // iterator.remove();\n            result = result.filter(function (x) {\n              return x !== oldState;\n            }); // remove old state\n          }\n        };\n        try {\n          for (var result_1 = (e_4 = void 0, __values(result)), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {\n            var oldState = result_1_1.value;\n            var state_1 = _loop_1(oldState);\n            if (state_1 === \"break\") break;\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (result_1_1 && !result_1_1.done && (_b = result_1.return)) _b.call(result_1);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n        if (add) {\n          result.push(newState);\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (states_3_1 && !states_3_1.done && (_a = states_3.return)) _a.call(states_3);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n    return result;\n  };\n  return HighLevelEncoder;\n}();\nexport default HighLevelEncoder;","map":{"version":3,"names":["Collections","State","C","CharMap","ShiftTable","StringUtils","HighLevelEncoder","text","prototype","encode","spaceCharCode","getCharCode","lineBreakCharCode","states","singletonList","INITIAL_STATE","index","length","pairCode","nextChar","updateStateListForPair","updateStateListForChar","minState","min","a","b","getBitCount","toBitArray","result","states_1","__values","states_1_1","next","done","state","value","updateStateForChar","simplifyStates","ch","charInCurrentTable","CHAR_MAP","getMode","stateNoBinary","mode","MODE_PUNCT","charInMode","endBinaryShift","MODE_DIGIT","latchState","latchAndAppend","push","SHIFT_TABLE","shiftState","shiftAndAppend","getBinaryShiftByteCount","binaryState","addBinaryShiftChar","states_2","states_2_1","updateStateForPair","digitState","states_3","states_3_1","newState","add","oldState","isBetterThanOrEqualTo","filter","x","result_1","e_4","result_1_1"],"sources":["../../../../../src/core/aztec/encoder/HighLevelEncoder.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}