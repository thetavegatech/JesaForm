{"ast":null,"code":"/*\n * Copyright 2007 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport IllegalArgumentException from '../../IllegalArgumentException';\n/**\n * <p>Encapsulates a block of data within a QR Code. QR Codes may split their data into\n * multiple blocks, each of which is a unit of data and error-correction codewords. Each\n * is represented by an instance of this class.</p>\n *\n * @author Sean Owen\n */\nvar DataBlock = /** @class */function () {\n  function DataBlock(numDataCodewords /*int*/, codewords) {\n    this.numDataCodewords = numDataCodewords;\n    this.codewords = codewords;\n  }\n  /**\n   * <p>When QR Codes use multiple data blocks, they are actually interleaved.\n   * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This\n   * method will separate the data into original blocks.</p>\n   *\n   * @param rawCodewords bytes as read directly from the QR Code\n   * @param version version of the QR Code\n   * @param ecLevel error-correction level of the QR Code\n   * @return DataBlocks containing original bytes, \"de-interleaved\" from representation in the\n   *         QR Code\n   */\n  DataBlock.getDataBlocks = function (rawCodewords, version, ecLevel) {\n    var e_1, _a, e_2, _b;\n    if (rawCodewords.length !== version.getTotalCodewords()) {\n      throw new IllegalArgumentException();\n    }\n    // Figure out the number and size of data blocks used by this version and\n    // error correction level\n    var ecBlocks = version.getECBlocksForLevel(ecLevel);\n    // First count the total number of data blocks\n    var totalBlocks = 0;\n    var ecBlockArray = ecBlocks.getECBlocks();\n    try {\n      for (var ecBlockArray_1 = __values(ecBlockArray), ecBlockArray_1_1 = ecBlockArray_1.next(); !ecBlockArray_1_1.done; ecBlockArray_1_1 = ecBlockArray_1.next()) {\n        var ecBlock = ecBlockArray_1_1.value;\n        totalBlocks += ecBlock.getCount();\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (ecBlockArray_1_1 && !ecBlockArray_1_1.done && (_a = ecBlockArray_1.return)) _a.call(ecBlockArray_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    // Now establish DataBlocks of the appropriate size and number of data codewords\n    var result = new Array(totalBlocks);\n    var numResultBlocks = 0;\n    try {\n      for (var ecBlockArray_2 = __values(ecBlockArray), ecBlockArray_2_1 = ecBlockArray_2.next(); !ecBlockArray_2_1.done; ecBlockArray_2_1 = ecBlockArray_2.next()) {\n        var ecBlock = ecBlockArray_2_1.value;\n        for (var i = 0; i < ecBlock.getCount(); i++) {\n          var numDataCodewords = ecBlock.getDataCodewords();\n          var numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;\n          result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (ecBlockArray_2_1 && !ecBlockArray_2_1.done && (_b = ecBlockArray_2.return)) _b.call(ecBlockArray_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n    // All blocks have the same amount of data, except that the last n\n    // (where n may be 0) have 1 more byte. Figure out where these start.\n    var shorterBlocksTotalCodewords = result[0].codewords.length;\n    var longerBlocksStartAt = result.length - 1;\n    // TYPESCRIPTPORT: check length is correct here\n    while (longerBlocksStartAt >= 0) {\n      var numCodewords = result[longerBlocksStartAt].codewords.length;\n      if (numCodewords === shorterBlocksTotalCodewords) {\n        break;\n      }\n      longerBlocksStartAt--;\n    }\n    longerBlocksStartAt++;\n    var shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();\n    // The last elements of result may be 1 element longer\n    // first fill out as many elements as all of them have\n    var rawCodewordsOffset = 0;\n    for (var i = 0; i < shorterBlocksNumDataCodewords; i++) {\n      for (var j = 0; j < numResultBlocks; j++) {\n        result[j].codewords[i] = rawCodewords[rawCodewordsOffset++];\n      }\n    }\n    // Fill out the last data block in the longer ones\n    for (var j = longerBlocksStartAt; j < numResultBlocks; j++) {\n      result[j].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];\n    }\n    // Now add in error correction blocks\n    var max = result[0].codewords.length;\n    for (var i = shorterBlocksNumDataCodewords; i < max; i++) {\n      for (var j = 0; j < numResultBlocks; j++) {\n        var iOffset = j < longerBlocksStartAt ? i : i + 1;\n        result[j].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];\n      }\n    }\n    return result;\n  };\n  DataBlock.prototype.getNumDataCodewords = function () {\n    return this.numDataCodewords;\n  };\n  DataBlock.prototype.getCodewords = function () {\n    return this.codewords;\n  };\n  return DataBlock;\n}();\nexport default DataBlock;","map":{"version":3,"names":["IllegalArgumentException","DataBlock","numDataCodewords","codewords","getDataBlocks","rawCodewords","version","ecLevel","length","getTotalCodewords","ecBlocks","getECBlocksForLevel","totalBlocks","ecBlockArray","getECBlocks","ecBlockArray_1","__values","ecBlockArray_1_1","next","done","ecBlock","value","getCount","result","Array","numResultBlocks","ecBlockArray_2","ecBlockArray_2_1","i","getDataCodewords","numBlockCodewords","getECCodewordsPerBlock","Uint8Array","shorterBlocksTotalCodewords","longerBlocksStartAt","numCodewords","shorterBlocksNumDataCodewords","rawCodewordsOffset","j","max","iOffset","prototype","getNumDataCodewords","getCodewords"],"sources":["../../../../../src/core/qrcode/decoder/DataBlock.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}