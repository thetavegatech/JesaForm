{"ast":null,"code":"/*\n * Copyright 2013 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n// package com.google.zxing.aztec.encoder;\n// import java.util.Deque;\n// import java.util.LinkedList;\n// import com.google.zxing.common.BitArray;\nimport BitArray from '../../common/BitArray';\nimport * as TokenHelpers from './TokenHelpers';\nimport * as C from './EncoderConstants';\nimport * as LatchTable from './LatchTable';\nimport * as ShiftTable from './ShiftTable';\nimport StringUtils from '../../common/StringUtils';\n/**\n * State represents all information about a sequence necessary to generate the current output.\n * Note that a state is immutable.\n */\nvar State = /** @class */function () {\n  function State(token, mode, binaryBytes, bitCount) {\n    this.token = token;\n    this.mode = mode;\n    this.binaryShiftByteCount = binaryBytes;\n    this.bitCount = bitCount;\n    // Make sure we match the token\n    // int binaryShiftBitCount = (binaryShiftByteCount * 8) +\n    //    (binaryShiftByteCount === 0 ? 0 :\n    //     binaryShiftByteCount <= 31 ? 10 :\n    //     binaryShiftByteCount <= 62 ? 20 : 21);\n    // assert this.bitCount === token.getTotalBitCount() + binaryShiftBitCount;\n  }\n  State.prototype.getMode = function () {\n    return this.mode;\n  };\n  State.prototype.getToken = function () {\n    return this.token;\n  };\n  State.prototype.getBinaryShiftByteCount = function () {\n    return this.binaryShiftByteCount;\n  };\n  State.prototype.getBitCount = function () {\n    return this.bitCount;\n  };\n  // Create a new state representing this state with a latch to a (not\n  // necessary different) mode, and then a code.\n  State.prototype.latchAndAppend = function (mode, value) {\n    // assert binaryShiftByteCount === 0;\n    var bitCount = this.bitCount;\n    var token = this.token;\n    if (mode !== this.mode) {\n      var latch = LatchTable.LATCH_TABLE[this.mode][mode];\n      token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);\n      bitCount += latch >> 16;\n    }\n    var latchModeBitCount = mode === C.MODE_DIGIT ? 4 : 5;\n    token = TokenHelpers.add(token, value, latchModeBitCount);\n    return new State(token, mode, 0, bitCount + latchModeBitCount);\n  };\n  // Create a new state representing this state, with a temporary shift\n  // to a different mode to output a single value.\n  State.prototype.shiftAndAppend = function (mode, value) {\n    // assert binaryShiftByteCount === 0 && this.mode !== mode;\n    var token = this.token;\n    var thisModeBitCount = this.mode === C.MODE_DIGIT ? 4 : 5;\n    // Shifts exist only to UPPER and PUNCT, both with tokens size 5.\n    token = TokenHelpers.add(token, ShiftTable.SHIFT_TABLE[this.mode][mode], thisModeBitCount);\n    token = TokenHelpers.add(token, value, 5);\n    return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);\n  };\n  // Create a new state representing this state, but an additional character\n  // output in Binary Shift mode.\n  State.prototype.addBinaryShiftChar = function (index) {\n    var token = this.token;\n    var mode = this.mode;\n    var bitCount = this.bitCount;\n    if (this.mode === C.MODE_PUNCT || this.mode === C.MODE_DIGIT) {\n      // assert binaryShiftByteCount === 0;\n      var latch = LatchTable.LATCH_TABLE[mode][C.MODE_UPPER];\n      token = TokenHelpers.add(token, latch & 0xffff, latch >> 16);\n      bitCount += latch >> 16;\n      mode = C.MODE_UPPER;\n    }\n    var deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31 ? 18 : this.binaryShiftByteCount === 62 ? 9 : 8;\n    var result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);\n    if (result.binaryShiftByteCount === 2047 + 31) {\n      // The string is as long as it's allowed to be.  We should end it.\n      result = result.endBinaryShift(index + 1);\n    }\n    return result;\n  };\n  // Create the state identical to this one, but we are no longer in\n  // Binary Shift mode.\n  State.prototype.endBinaryShift = function (index) {\n    if (this.binaryShiftByteCount === 0) {\n      return this;\n    }\n    var token = this.token;\n    token = TokenHelpers.addBinaryShift(token, index - this.binaryShiftByteCount, this.binaryShiftByteCount);\n    // assert token.getTotalBitCount() === this.bitCount;\n    return new State(token, this.mode, 0, this.bitCount);\n  };\n  // Returns true if \"this\" state is better (equal: or) to be in than \"that\"\n  // state under all possible circumstances.\n  State.prototype.isBetterThanOrEqualTo = function (other) {\n    var newModeBitCount = this.bitCount + (LatchTable.LATCH_TABLE[this.mode][other.mode] >> 16);\n    if (this.binaryShiftByteCount < other.binaryShiftByteCount) {\n      // add additional B/S encoding cost of other, if any\n      newModeBitCount += State.calculateBinaryShiftCost(other) - State.calculateBinaryShiftCost(this);\n    } else if (this.binaryShiftByteCount > other.binaryShiftByteCount && other.binaryShiftByteCount > 0) {\n      // maximum possible additional cost (it: h)\n      newModeBitCount += 10;\n    }\n    return newModeBitCount <= other.bitCount;\n  };\n  State.prototype.toBitArray = function (text) {\n    var e_1, _a;\n    // Reverse the tokens, so that they are in the order that they should\n    // be output\n    var symbols = [];\n    for (var token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {\n      symbols.unshift(token);\n    }\n    var bitArray = new BitArray();\n    try {\n      // Add each token to the result.\n      for (var symbols_1 = __values(symbols), symbols_1_1 = symbols_1.next(); !symbols_1_1.done; symbols_1_1 = symbols_1.next()) {\n        var symbol = symbols_1_1.value;\n        symbol.appendTo(bitArray, text);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (symbols_1_1 && !symbols_1_1.done && (_a = symbols_1.return)) _a.call(symbols_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    // assert bitArray.getSize() === this.bitCount;\n    return bitArray;\n  };\n  /**\n   * @Override\n   */\n  State.prototype.toString = function () {\n    return StringUtils.format('%s bits=%d bytes=%d', C.MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);\n  };\n  State.calculateBinaryShiftCost = function (state) {\n    if (state.binaryShiftByteCount > 62) {\n      return 21; // B/S with extended length\n    }\n    if (state.binaryShiftByteCount > 31) {\n      return 20; // two B/S\n    }\n    if (state.binaryShiftByteCount > 0) {\n      return 10; // one B/S\n    }\n    return 0;\n  };\n  State.INITIAL_STATE = new State(C.EMPTY_TOKEN, C.MODE_UPPER, 0, 0);\n  return State;\n}();\nexport default State;","map":{"version":3,"names":["BitArray","TokenHelpers","C","LatchTable","ShiftTable","StringUtils","State","token","mode","binaryBytes","bitCount","binaryShiftByteCount","prototype","getMode","getToken","getBinaryShiftByteCount","getBitCount","latchAndAppend","value","latch","LATCH_TABLE","add","latchModeBitCount","MODE_DIGIT","shiftAndAppend","thisModeBitCount","SHIFT_TABLE","addBinaryShiftChar","index","MODE_PUNCT","MODE_UPPER","deltaBitCount","result","endBinaryShift","addBinaryShift","isBetterThanOrEqualTo","other","newModeBitCount","calculateBinaryShiftCost","toBitArray","text","symbols","length","getPrevious","unshift","bitArray","symbols_1","__values","symbols_1_1","next","done","symbol","appendTo","toString","format","MODE_NAMES","state","INITIAL_STATE","EMPTY_TOKEN"],"sources":["../../../../../src/core/aztec/encoder/State.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}