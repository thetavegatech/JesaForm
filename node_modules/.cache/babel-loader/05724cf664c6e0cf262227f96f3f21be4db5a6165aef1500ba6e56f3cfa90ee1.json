{"ast":null,"code":"/*\n * Copyright (C) 2012 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport BarcodeFormat from '../BarcodeFormat';\nimport AbstractUPCEANReader from './AbstractUPCEANReader';\nimport Result from '../Result';\nimport ResultPoint from '../ResultPoint';\nimport ResultMetadataType from '../ResultMetadataType';\nimport NotFoundException from '../NotFoundException';\n/**\n * @see UPCEANExtension5Support\n */\nvar UPCEANExtension2Support = /** @class */function () {\n  function UPCEANExtension2Support() {\n    this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);\n    this.decodeRowStringBuffer = '';\n  }\n  UPCEANExtension2Support.prototype.decodeRow = function (rowNumber, row, extensionStartRange) {\n    var result = this.decodeRowStringBuffer;\n    var end = this.decodeMiddle(row, extensionStartRange, result);\n    var resultString = result.toString();\n    var extensionData = UPCEANExtension2Support.parseExtensionString(resultString);\n    var resultPoints = [new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2.0, rowNumber), new ResultPoint(end, rowNumber)];\n    var extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat.UPC_EAN_EXTENSION, new Date().getTime());\n    if (extensionData != null) {\n      extensionResult.putAllMetadata(extensionData);\n    }\n    return extensionResult;\n  };\n  UPCEANExtension2Support.prototype.decodeMiddle = function (row, startRange, resultString) {\n    var e_1, _a;\n    var counters = this.decodeMiddleCounters;\n    counters[0] = 0;\n    counters[1] = 0;\n    counters[2] = 0;\n    counters[3] = 0;\n    var end = row.getSize();\n    var rowOffset = startRange[1];\n    var checkParity = 0;\n    for (var x = 0; x < 2 && rowOffset < end; x++) {\n      var bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);\n      resultString += String.fromCharCode('0'.charCodeAt(0) + bestMatch % 10);\n      try {\n        for (var counters_1 = (e_1 = void 0, __values(counters)), counters_1_1 = counters_1.next(); !counters_1_1.done; counters_1_1 = counters_1.next()) {\n          var counter = counters_1_1.value;\n          rowOffset += counter;\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (counters_1_1 && !counters_1_1.done && (_a = counters_1.return)) _a.call(counters_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      if (bestMatch >= 10) {\n        checkParity |= 1 << 1 - x;\n      }\n      if (x !== 1) {\n        // Read off separator if not last\n        rowOffset = row.getNextSet(rowOffset);\n        rowOffset = row.getNextUnset(rowOffset);\n      }\n    }\n    if (resultString.length !== 2) {\n      throw new NotFoundException();\n    }\n    if (parseInt(resultString.toString()) % 4 !== checkParity) {\n      throw new NotFoundException();\n    }\n    return rowOffset;\n  };\n  UPCEANExtension2Support.parseExtensionString = function (raw) {\n    if (raw.length !== 2) {\n      return null;\n    }\n    return new Map([[ResultMetadataType.ISSUE_NUMBER, parseInt(raw)]]);\n  };\n  return UPCEANExtension2Support;\n}();\nexport default UPCEANExtension2Support;","map":{"version":3,"names":["BarcodeFormat","AbstractUPCEANReader","Result","ResultPoint","ResultMetadataType","NotFoundException","UPCEANExtension2Support","decodeMiddleCounters","Int32Array","from","decodeRowStringBuffer","prototype","decodeRow","rowNumber","row","extensionStartRange","result","end","decodeMiddle","resultString","toString","extensionData","parseExtensionString","resultPoints","extensionResult","UPC_EAN_EXTENSION","Date","getTime","putAllMetadata","startRange","counters","getSize","rowOffset","checkParity","x","bestMatch","decodeDigit","L_AND_G_PATTERNS","String","fromCharCode","charCodeAt","counters_1","e_1","__values","counters_1_1","next","done","counter","value","getNextSet","getNextUnset","length","parseInt","raw","Map","ISSUE_NUMBER"],"sources":["../../../../src/core/oned/UPCEANExtension2Support.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}