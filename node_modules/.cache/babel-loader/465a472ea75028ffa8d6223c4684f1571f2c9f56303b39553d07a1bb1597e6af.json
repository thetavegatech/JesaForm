{"ast":null,"code":"/*\n * Copyright 2008 ZXing authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n    m = s && o[s],\n    i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nimport BarcodeFormat from '../BarcodeFormat';\nimport DecodeHintType from '../DecodeHintType';\nimport Result from '../Result';\nimport OneDReader from './OneDReader';\nimport EAN13Reader from './EAN13Reader';\nimport EAN8Reader from './EAN8Reader';\nimport UPCAReader from './UPCAReader';\nimport NotFoundException from '../NotFoundException';\nimport UPCEReader from './UPCEReader';\n/**\n * <p>A reader that can read all available UPC/EAN formats. If a caller wants to try to\n * read all such formats, it is most efficient to use this implementation rather than invoke\n * individual readers.</p>\n *\n * @author Sean Owen\n */\nvar MultiFormatUPCEANReader = /** @class */function (_super) {\n  __extends(MultiFormatUPCEANReader, _super);\n  function MultiFormatUPCEANReader(hints) {\n    var _this = _super.call(this) || this;\n    var possibleFormats = hints == null ? null : hints.get(DecodeHintType.POSSIBLE_FORMATS);\n    var readers = [];\n    if (possibleFormats != null) {\n      if (possibleFormats.indexOf(BarcodeFormat.EAN_13) > -1) {\n        readers.push(new EAN13Reader());\n      } else if (possibleFormats.indexOf(BarcodeFormat.UPC_A) > -1) {\n        readers.push(new UPCAReader());\n      }\n      if (possibleFormats.indexOf(BarcodeFormat.EAN_8) > -1) {\n        readers.push(new EAN8Reader());\n      }\n      if (possibleFormats.indexOf(BarcodeFormat.UPC_E) > -1) {\n        readers.push(new UPCEReader());\n      }\n    }\n    if (readers.length === 0) {\n      readers.push(new EAN13Reader());\n      // UPC-A is covered by EAN-13\n      readers.push(new EAN8Reader());\n      readers.push(new UPCEReader());\n    }\n    _this.readers = readers;\n    return _this;\n  }\n  MultiFormatUPCEANReader.prototype.decodeRow = function (rowNumber, row, hints) {\n    var e_1, _a;\n    try {\n      for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var reader = _c.value;\n        try {\n          // const result: Result = reader.decodeRow(rowNumber, row, startGuardPattern, hints);\n          var result = reader.decodeRow(rowNumber, row, hints);\n          // Special case: a 12-digit code encoded in UPC-A is identical to a \"0\"\n          // followed by those 12 digits encoded as EAN-13. Each will recognize such a code,\n          // UPC-A as a 12-digit string and EAN-13 as a 13-digit string starting with \"0\".\n          // Individually these are correct and their readers will both read such a code\n          // and correctly call it EAN-13, or UPC-A, respectively.\n          //\n          // In this case, if we've been looking for both types, we'd like to call it\n          // a UPC-A code. But for efficiency we only run the EAN-13 decoder to also read\n          // UPC-A. So we special case it here, and convert an EAN-13 result to a UPC-A\n          // result if appropriate.\n          //\n          // But, don't return UPC-A if UPC-A was not a requested format!\n          var ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat.EAN_13 && result.getText().charAt(0) === '0';\n          // @SuppressWarnings(\"unchecked\")\n          var possibleFormats = hints == null ? null : hints.get(DecodeHintType.POSSIBLE_FORMATS);\n          var canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat.UPC_A);\n          if (ean13MayBeUPCA && canReturnUPCA) {\n            var rawBytes = result.getRawBytes();\n            // Transfer the metadata across\n            var resultUPCA = new Result(result.getText().substring(1), rawBytes, rawBytes.length, result.getResultPoints(), BarcodeFormat.UPC_A);\n            resultUPCA.putAllMetadata(result.getResultMetadata());\n            return resultUPCA;\n          }\n          return result;\n        } catch (err) {\n          // continue;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    throw new NotFoundException();\n  };\n  MultiFormatUPCEANReader.prototype.reset = function () {\n    var e_2, _a;\n    try {\n      for (var _b = __values(this.readers), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var reader = _c.value;\n        reader.reset();\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n  };\n  return MultiFormatUPCEANReader;\n}(OneDReader);\nexport default MultiFormatUPCEANReader;","map":{"version":3,"names":["BarcodeFormat","DecodeHintType","Result","OneDReader","EAN13Reader","EAN8Reader","UPCAReader","NotFoundException","UPCEReader","MultiFormatUPCEANReader","_super","__extends","hints","_this","call","possibleFormats","get","POSSIBLE_FORMATS","readers","indexOf","EAN_13","push","UPC_A","EAN_8","UPC_E","length","prototype","decodeRow","rowNumber","row","_b","__values","_c","next","done","reader","value","result","ean13MayBeUPCA","getBarcodeFormat","getText","charAt","canReturnUPCA","includes","rawBytes","getRawBytes","resultUPCA","substring","getResultPoints","putAllMetadata","getResultMetadata","err","reset"],"sources":["../../../../src/core/oned/MultiFormatUPCEANReader.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}